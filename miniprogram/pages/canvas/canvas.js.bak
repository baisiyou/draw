const app = getApp()
const api = require('../../utils/api.js')

Page({
  data: {
    canvasId: 'excalidraw-canvas',
    drawingId: null,
    elements: [],
    appState: {
      viewBackgroundColor: '#ffffff',
      currentItemStrokeColor: '#000000',
      currentItemBackgroundColor: 'transparent',
      currentItemFillStyle: 'hachure',
      currentItemStrokeWidth: 1,
      currentItemRoughness: 1,
      currentItemOpacity: 100,
      currentItemFontFamily: 1,
      currentItemFontSize: 20,
      currentItemTextAlign: 'left',
      currentItemStrokeStyle: 'solid',
      currentItemRoundness: 'round',
      gridSize: null,
      zoom: { value: 1 },
      scrollX: 0,
      scrollY: 0
    },
    isDrawing: false,
    startX: 0,
    startY: 0,
    currentPath: null,
    saving: false,
    loading: false,
    currentTool: 'pen', // 当前工具：pen, rectangle, ellipse, text
    showTextInput: false, // 是否显示文字输入框
    textInputX: 0, // 文字输入位置 X
    textInputY: 0, // 文字输入位置 Y
    textInputValue: '' // 文字输入内容
  },

  onLoad(options) {
    if (options.id) {
      this.setData({ drawingId: options.id })
      this.loadDrawing(options.id)
    } else {
      // 初始化画布
      this.initCanvas()
    }
  },

  onReady() {
    // 页面渲染完成后初始化画布
    this.initCanvas()
  },

  // 初始化画布
  initCanvas() {
    // 延迟一下确保 canvas 已渲染
    setTimeout(() => {
      this.redrawCanvas()
    }, 100)
  },

  // 重绘画布
  redrawCanvas() {
    const ctx = wx.createCanvasContext(this.data.canvasId)
    // 清空画布
    ctx.clearRect(0, 0, 1000, 1000)
    // 绘制所有元素
    this.data.elements.forEach(element => {
      this.drawElement(ctx, element)
    })
    ctx.draw()
  },

  onUnload() {
    // 清理定时器
    if (this.saveTimer) {
      clearTimeout(this.saveTimer)
      this.saveTimer = null
    }
    // 页面卸载前保存
    if (this.data.elements.length > 0) {
      this.saveDrawing()
    }
  },

  // 加载绘图（优先从后端加载，失败则从本地加载）
  async loadDrawing(id) {
    this.setData({ loading: true })
    
    try {
      // 先尝试从后端加载
      const data = await api.loadDrawingFromBackend(id)
      this.setData({
        elements: data.elements || [],
        appState: data.appState || this.data.appState,
        drawingId: id
      })
      // 重新绘制画布
      this.redrawCanvas()
      wx.showToast({
        title: '加载成功',
        icon: 'success'
      })
    } catch (err) {
      console.log('从后端加载失败，尝试从本地加载:', err)
      // 从本地存储加载
      const drawings = wx.getStorageSync('drawings') || []
      const drawing = drawings.find(d => d.id === id)
      if (drawing) {
        this.setData({
          elements: drawing.elements || [],
          appState: drawing.appState || this.data.appState
        })
        // 重新绘制画布
        this.redrawCanvas()
        wx.showToast({
          title: '从本地加载',
          icon: 'none'
        })
      } else {
        wx.showToast({
          title: '加载失败',
          icon: 'error'
        })
      }
    } finally {
      this.setData({ loading: false })
    }
  },

  // 保存绘图（同时保存到后端和本地）
  async saveDrawing() {
    if (this.data.saving) return
    
    this.setData({ saving: true })
    
    const drawingData = {
      id: this.data.drawingId || Date.now().toString(),
      name: `绘图 ${new Date().toLocaleString()}`,
      elements: this.data.elements,
      appState: this.data.appState,
      time: new Date().toLocaleString()
    }

    // 如果没有ID，先设置ID
    if (!this.data.drawingId) {
      this.setData({ drawingId: drawingData.id })
    }

    try {
      // 保存到后端
      const result = await api.saveDrawingToBackend(drawingData)
      if (result.id) {
        drawingData.id = result.id
        this.setData({ drawingId: result.id })
      }
      
      // 同时保存到本地存储
      const drawings = wx.getStorageSync('drawings') || []
      const index = drawings.findIndex(d => d.id === drawingData.id)
      if (index >= 0) {
        drawings[index] = drawingData
      } else {
        drawings.push(drawingData)
      }
      wx.setStorageSync('drawings', drawings)
      
      wx.showToast({
        title: '保存成功',
        icon: 'success'
      })
    } catch (err) {
      console.error('保存到后端失败:', err)
      // 即使后端保存失败，也保存到本地
      const drawings = wx.getStorageSync('drawings') || []
      const index = drawings.findIndex(d => d.id === drawingData.id)
      if (index >= 0) {
        drawings[index] = drawingData
      } else {
        drawings.push(drawingData)
      }
      wx.setStorageSync('drawings', drawings)
      
      wx.showToast({
        title: '已保存到本地',
        icon: 'none'
      })
    } finally {
      this.setData({ saving: false })
    }
  },

  // 导出绘图
  exportDrawing() {
    wx.showActionSheet({
      itemList: ['保存到相册', '分享'],
      success: (res) => {
        if (res.tapIndex === 0) {
          this.saveToAlbum()
        } else if (res.tapIndex === 1) {
          this.shareDrawing()
        }
      }
    })
  },

  // 保存到相册
  saveToAlbum() {
    const ctx = wx.createCanvasContext(this.data.canvasId)
    // 绘制所有元素
    this.data.elements.forEach(element => {
      this.drawElement(ctx, element)
    })
    ctx.draw(false, () => {
      wx.canvasToTempFilePath({
        canvasId: this.data.canvasId,
        success: (res) => {
          wx.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              wx.showToast({
                title: '保存成功',
                icon: 'success'
              })
            }
          })
        }
      })
    })
  },

  // 绘制元素
  drawElement(ctx, element) {
    ctx.setStrokeStyle(element.strokeColor || '#000000')
    ctx.setFillStyle(element.backgroundColor || 'transparent')
    ctx.setLineWidth(element.strokeWidth || 1)

    switch (element.type) {
      case 'rectangle':
        ctx.beginPath()
        ctx.rect(element.x, element.y, element.width, element.height)
        ctx.stroke()
        if (element.backgroundColor !== 'transparent') {
          ctx.fill()
        }
        break
      case 'ellipse':
        ctx.beginPath()
        ctx.ellipse(
          element.x + element.width / 2,
          element.y + element.height / 2,
          element.width / 2,
          element.height / 2,
          0,
          0,
          2 * Math.PI
        )
        ctx.stroke()
        if (element.backgroundColor !== 'transparent') {
          ctx.fill()
        }
        break
      case 'line':
        ctx.beginPath()
        ctx.moveTo(element.points[0], element.points[1])
        for (let i = 2; i < element.points.length; i += 2) {
          ctx.lineTo(element.points[i], element.points[i + 1])
        }
        ctx.stroke()
        break
      case 'text':
        ctx.setFillStyle(element.strokeColor || '#000000')
        ctx.setFontSize(element.fontSize || 20)
        ctx.fillText(element.text, element.x, element.y)
        break
    }
  },

  // 触摸开始
  touchStart(e) {
    const touch = e.touches[0]
    // 获取相对于 canvas 的坐标
    const query = wx.createSelectorQuery()
    query.select('.canvas').boundingClientRect((rect) => {
      const x = touch.clientX - (rect ? rect.left : 0)
      const y = touch.clientY - (rect ? rect.top : 0)
      
      // 如果是文字工具，显示输入框
      if (this.data.currentTool === 'text') {
        this.setData({
          showTextInput: true,
          textInputX: x,
          textInputY: y,
          textInputValue: ''
        })
        return
      }
      
      // 如果是矩形或圆形工具
      if (this.data.currentTool === 'rectangle' || this.data.currentTool === 'ellipse') {
        this.setData({
          isDrawing: true,
          startX: x,
          startY: y
        })
        return
      }
      
      // 画笔工具
      this.setData({
        isDrawing: true,
        startX: x,
        startY: y,
        currentPath: {
          points: [x, y],
          strokeColor: this.data.appState.currentItemStrokeColor,
          strokeWidth: this.data.appState.currentItemStrokeWidth
        }
      })
    }).exec()
  },

  // 触摸移动
  touchMove(e) {
    // 文字工具不需要移动事件
    if (this.data.currentTool === 'text') return
    
    // 矩形和圆形工具
    if (this.data.currentTool === 'rectangle' || this.data.currentTool === 'ellipse') {
      if (!this.data.isDrawing) return
      
      const touch = e.touches[0]
      const query = wx.createSelectorQuery()
      query.select('.canvas').boundingClientRect((rect) => {
        const x = touch.clientX - (rect ? rect.left : 0)
        const y = touch.clientY - (rect ? rect.top : 0)
        
        // 实时绘制预览
        const ctx = wx.createCanvasContext(this.data.canvasId)
        // 先重绘所有已有元素
        this.data.elements.forEach(element => {
          this.drawElement(ctx, element)
        })
        // 绘制预览
        ctx.setStrokeStyle(this.data.appState.currentItemStrokeColor)
        ctx.setLineWidth(this.data.appState.currentItemStrokeWidth)
        ctx.beginPath()
        if (this.data.currentTool === 'rectangle') {
          ctx.rect(
            Math.min(this.data.startX, x),
            Math.min(this.data.startY, y),
            Math.abs(x - this.data.startX),
            Math.abs(y - this.data.startY)
          )
        } else {
          ctx.ellipse(
            (this.data.startX + x) / 2,
            (this.data.startY + y) / 2,
            Math.abs(x - this.data.startX) / 2,
            Math.abs(y - this.data.startY) / 2,
            0,
            0,
            2 * Math.PI
          )
        }
        ctx.stroke()
        ctx.draw()
      }).exec()
      return
    }
    
    // 画笔工具
    if (!this.data.isDrawing || !this.data.currentPath) return

    const touch = e.touches[0]
    const query = wx.createSelectorQuery()
    query.select('.canvas').boundingClientRect((rect) => {
      const x = touch.clientX - (rect ? rect.left : 0)
      const y = touch.clientY - (rect ? rect.top : 0)
      
      // 添加到当前路径
      const currentPath = {
        ...this.data.currentPath,
        points: [...this.data.currentPath.points, x, y]
      }
      
      this.setData({
        currentPath
      })

      // 实时绘制
      const ctx = wx.createCanvasContext(this.data.canvasId)
      // 先重绘所有已有元素
      this.data.elements.forEach(element => {
        this.drawElement(ctx, element)
      })
      // 绘制当前路径
      ctx.setStrokeStyle(currentPath.strokeColor)
      ctx.setLineWidth(currentPath.strokeWidth)
      ctx.beginPath()
      ctx.moveTo(currentPath.points[0], currentPath.points[1])
      for (let i = 2; i < currentPath.points.length; i += 2) {
        ctx.lineTo(currentPath.points[i], currentPath.points[i + 1])
      }
      ctx.stroke()
      ctx.draw()
    }).exec()
  },

  // 触摸结束
  touchEnd(e) {
    // 文字工具不需要结束事件
    if (this.data.currentTool === 'text') return
    
    // 矩形和圆形工具
    if (this.data.currentTool === 'rectangle' || this.data.currentTool === 'ellipse') {
      if (!this.data.isDrawing) {
        this.setData({ isDrawing: false })
        return
      }
      
      const touch = e.changedTouches[0]
      const query = wx.createSelectorQuery()
      query.select('.canvas').boundingClientRect((rect) => {
        const x = touch.clientX - (rect ? rect.left : 0)
        const y = touch.clientY - (rect ? rect.top : 0)
        
        const newElement = {
          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
          type: this.data.currentTool,
          strokeColor: this.data.appState.currentItemStrokeColor,
          strokeWidth: this.data.appState.currentItemStrokeWidth,
          backgroundColor: this.data.appState.currentItemBackgroundColor,
          x: Math.min(this.data.startX, x),
          y: Math.min(this.data.startY, y),
          width: Math.abs(x - this.data.startX),
          height: Math.abs(y - this.data.startY)
        }
        
        const elements = [...this.data.elements, newElement]
        this.setData({
          elements,
          isDrawing: false
        })
        
        // 重新绘制画布
        this.redrawCanvas()
        
        // 延迟保存
        if (this.saveTimer) {
          clearTimeout(this.saveTimer)
        }
        this.saveTimer = setTimeout(() => {
          this.saveDrawing()
        }, 1000)
      }).exec()
      return
    }
    
    // 画笔工具
    if (!this.data.isDrawing || !this.data.currentPath) {
      this.setData({ isDrawing: false, currentPath: null })
      return
    }

    // 保存当前路径为元素
    if (this.data.currentPath.points.length >= 4) {
      const points = this.data.currentPath.points
      const newElement = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        type: 'line',
        strokeColor: this.data.currentPath.strokeColor,
        strokeWidth: this.data.currentPath.strokeWidth,
        points: points,
        x: Math.min(...points.filter((_, i) => i % 2 === 0)),
        y: Math.min(...points.filter((_, i) => i % 2 === 1)),
        width: Math.max(...points.filter((_, i) => i % 2 === 0)) - Math.min(...points.filter((_, i) => i % 2 === 0)),
        height: Math.max(...points.filter((_, i) => i % 2 === 1)) - Math.min(...points.filter((_, i) => i % 2 === 1))
      }

      const elements = [...this.data.elements, newElement]
      this.setData({
        elements,
        isDrawing: false,
        currentPath: null
      })

      // 重新绘制画布
      this.redrawCanvas()
    } else {
      this.setData({ isDrawing: false, currentPath: null })
    }

    // 延迟保存，避免频繁请求
    if (this.saveTimer) {
      clearTimeout(this.saveTimer)
    }
    this.saveTimer = setTimeout(() => {
      this.saveDrawing()
    }, 1000)
  },

  // 文字输入确认
  onTextInputConfirm(e) {
    const text = e.detail.value.trim()
    if (text) {
      const newElement = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        type: 'text',
        text: text,
        strokeColor: this.data.appState.currentItemStrokeColor,
        fontSize: this.data.appState.currentItemFontSize,
        x: this.data.textInputX,
        y: this.data.textInputY
      }
      
      const elements = [...this.data.elements, newElement]
      this.setData({
        elements,
        showTextInput: false,
        textInputValue: ''
      })
      
      // 重新绘制画布
      this.redrawCanvas()
      
      // 延迟保存
      if (this.saveTimer) {
        clearTimeout(this.saveTimer)
      }
      this.saveTimer = setTimeout(() => {
        this.saveDrawing()
      }, 1000)
    } else {
      this.setData({
        showTextInput: false,
        textInputValue: ''
      })
    }
  },

  // 文字输入取消
  onTextInputCancel() {
    this.setData({
      showTextInput: false,
      textInputValue: ''
    })
  },

  // 清空画布
  clearCanvas() {
    wx.showModal({
      title: '确认清空',
      content: '确定要清空画布吗？',
      success: (res) => {
        if (res.confirm) {
          this.setData({ elements: [] })
          this.redrawCanvas()
        }
      }
    })
  },

  // 选择工具
  selectTool(e) {
    const tool = e.currentTarget.dataset.tool
    this.setData({ currentTool: tool })
    console.log('Selected tool:', tool)
    
    // 如果切换到文字工具，提示用户点击画布添加文字
    if (tool === 'text') {
      wx.showToast({
        title: '点击画布添加文字',
        icon: 'none',
        duration: 2000
      })
    }
  },
})

